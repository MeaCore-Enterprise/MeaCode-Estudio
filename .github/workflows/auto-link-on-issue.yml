name: Auto link and project on issue

on:
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write
  repository-projects: write

jobs:
  sync_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Add to Project "Planificacion", set Status "Por Hacer", link to Epic, and create sub-issues from task list
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Avoid loops when workflow edits the issue body
            if (context.actor === 'github-actions[bot]') {
              core.info('Skip: triggered by bot edit');
              return;
            }

            const projectName = 'Planificacion';
            const v2StatusFieldName = 'Status';
            const v2StatusOptionName = 'Por Hacer';
            const classicColumnName = 'Por Hacer';
            const defaultEpicNumber = 1;
            const assignee = 'KronoxYT';
            const labelName = 'todo';

            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title;
            let issueBody = issue.body || '';

            const eqNoDiacritics = (a,b) => {
              const norm = s => (s||'').normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
              return norm(a) === norm(b);
            };

            async function ensureLabel(labelName, color = '0e8a16') {
              try { await github.rest.issues.getLabel({ owner, repo, name: labelName }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name: labelName, color }); }
            }

            await ensureLabel(labelName);
            try { await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [labelName] }); } catch {}
            try { await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [assignee] }); } catch {}

            // Find Epic automatically: body hint > label pattern > title pattern > default
            const isEpicItself = /^\s*Epic\s+\d+/i.test(issueTitle);
            let epicNumber = defaultEpicNumber;
            if (!isEpicItself) {
              const bodyMatch = issueBody.match(/Epic[:\s]*#(\d+)/i);
              if (bodyMatch) {
                epicNumber = parseInt(bodyMatch[1], 10);
              } else {
                const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);
                let found = null;
                for (const name of labels) {
                  const m = name.match(/epic[-\s:]*(\d+)/i);
                  if (m) { found = parseInt(m[1], 10); break; }
                }
                if (found) {
                  epicNumber = found;
                } else {
                  const titleMatch = issueTitle.match(/\b[Ee]pic[-\s:]*(\d+)/);
                  if (titleMatch) epicNumber = parseInt(titleMatch[1], 10);
                }
              }
            }

            // Project v2 detection
            async function findProjectV2Id() {
              try {
                const orgQuery = `query($login:String!){ organization(login:$login){ projectsV2(first:100){ nodes{ id title } } } }`;
                const orgRes = await github.graphql(orgQuery, { login: owner });
                const foundOrg = orgRes.organization?.projectsV2?.nodes?.find(p => eqNoDiacritics(p.title, projectName));
                if (foundOrg) return foundOrg.id;
              } catch {}
              try {
                const userQuery = `query($login:String!){ user(login:$login){ projectsV2(first:100){ nodes{ id title } } } }`;
                const userRes = await github.graphql(userQuery, { login: owner });
                const foundUser = userRes.user?.projectsV2?.nodes?.find(p => eqNoDiacritics(p.title, projectName));
                if (foundUser) return foundUser.id;
              } catch {}
              return null;
            }

            async function getIssueNodeId(number) {
              const q = `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id } } }`;
              const r = await github.graphql(q, { owner, repo, number });
              return r.repository.issue.id;
            }

            const projectV2Id = await findProjectV2Id();
            let addedToV2 = false;
            if (projectV2Id) {
              // Discover Status field/option
              let statusFieldId = null, statusOptionId = null;
              try {
                const fieldsQuery = `query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2{ fields(first:50){ nodes{ id name dataType ... on ProjectV2SingleSelectField { options { id name } } } } } } }`;
                const fieldsRes = await github.graphql(fieldsQuery, { projectId: projectV2Id });
                const nodes = fieldsRes.node?.fields?.nodes || [];
                const statusField = nodes.find(f => f.name === v2StatusFieldName && f.options);
                if (statusField) {
                  statusFieldId = statusField.id;
                  statusOptionId = statusField.options.find(o => o.name === v2StatusOptionName)?.id || null;
                }
              } catch {}

              // Ensure the issue is an item of project v2
              async function getIssueNodeAndItem(number) {
                const q = `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id projectItems(first:100){ nodes{ id project{ id } } } } } }`;
                const r = await github.graphql(q, { owner, repo, number });
                const issue = r.repository.issue;
                const exist = (issue.projectItems?.nodes||[]).find(n => n.project?.id === projectV2Id);
                return { issueNodeId: issue.id, itemId: exist?.id || null };
              }

              async function setStatus(projectId, itemId) {
                if (itemId && statusFieldId && statusOptionId) {
                  const setMutation = `mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}){ projectV2Item { id } } }`;
                  try { await github.graphql(setMutation, { projectId, itemId, fieldId: statusFieldId, optionId: statusOptionId }); } catch {}
                }
              }

              const { issueNodeId, itemId: existingItemId } = await getIssueNodeAndItem(issueNumber);
              let itemId = existingItemId;
              if (!itemId) {
                const addMutation = `mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`;
                const addRes = await github.graphql(addMutation, { projectId: projectV2Id, contentId: issueNodeId });
                itemId = addRes.addProjectV2ItemById?.item?.id || null;
              }
              await setStatus(projectV2Id, itemId);
              addedToV2 = true;
            }

            if (!addedToV2) {
              // Classic projects fallback
              const inertia = { accept: 'application/vnd.github.inertia-preview+json' };
              async function addToClassicProject(proj) {
                const columns = await github.request('GET /projects/{project_id}/columns', { project_id: proj.id, headers: inertia });
                const targetCol = columns.data.find(c => eqNoDiacritics(c.name, classicColumnName)) || columns.data[0];
                const ghIssue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                await github.request('POST /projects/columns/{column_id}/cards', {
                  column_id: targetCol.id,
                  content_id: ghIssue.data.id,
                  content_type: 'Issue',
                  headers: inertia,
                });
              }
              try {
                const repoProjects = await github.request('GET /repos/{owner}/{repo}/projects', { owner, repo, headers: inertia });
                const proj = repoProjects.data.find(p => eqNoDiacritics(p.name, projectName));
                if (proj) await addToClassicProject(proj);
              } catch {}
            }

            // Link to Epic as sub-issue via task list
            if (!isEpicItself && epicNumber && epicNumber !== issueNumber) {
              try {
                const epic = await github.rest.issues.get({ owner, repo, issue_number: epicNumber });
                let epicBody = epic.data.body || '';
                const ref = `#${issueNumber}`;
                if (!epicBody.includes(ref)) {
                  epicBody += `\n- [ ] ${ref} ${issueTitle}`;
                  await github.rest.issues.update({ owner, repo, issue_number: epicNumber, body: epicBody });
                }
              } catch (e) {
                core.warning('No se pudo actualizar el Epic #' + epicNumber + ': ' + e.message);
              }
            }

            // Create sub-issues from unchecked tasks in the body
            // Lines like: - [ ] Tarea 1
            const lines = issueBody.split('\n');
            const taskRegex = /^-\s*\[ \]\s+(.+)$/;
            const childRefs = []; // will store created or found child numbers
            let changed = false;

            function hasIssueRef(text) { return /#\d+/.test(text); }

            for (let i = 0; i < lines.length; i++) {
              const m = lines[i].match(taskRegex);
              if (!m) continue;
              const text = m[1].trim();
              if (hasIssueRef(text)) continue; // already linked to an issue

              // Try to find an existing open issue with same title
              let child = null;
              try {
                const q = `repo:${owner}/${repo} type:issue in:title "${text.replace(/"/g,'\\"')}" state:open`;
                const res = await github.rest.search.issuesAndPullRequests({ q });
                child = res.data.items.find(i => i.title.toLowerCase() === text.toLowerCase() && i.state !== 'closed') || null;
              } catch {}

              if (!child) {
                const res = await github.rest.issues.create({ owner, repo, title: text, body: `Subtarea de #${issueNumber}`, labels: [labelName], assignees: [assignee] })
                  .catch(async (err) => {
                    if (err.status === 422 || err.status === 404) {
                      const res2 = await github.rest.issues.create({ owner, repo, title: text, body: `Subtarea de #${issueNumber}`, labels: [labelName] });
                      return res2;
                    }
                    throw err;
                  });
                child = res.data;
              }

              childRefs.push(child.number);

              // Add child to project and set status
              if (projectV2Id) {
                try {
                  const childNodeId = await getIssueNodeId(child.number);
                  const addMutation = `mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`;
                  const addRes = await github.graphql(addMutation, { projectId: projectV2Id, contentId: childNodeId });
                  const itemId = addRes.addProjectV2ItemById?.item?.id || null;
                  if (itemId && v2StatusFieldName && v2StatusOptionName) {
                    const fieldsQuery = `query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2{ fields(first:50){ nodes{ id name ... on ProjectV2SingleSelectField { options { id name } } } } } } }`;
                    const fieldsRes = await github.graphql(fieldsQuery, { projectId: projectV2Id });
                    const nodes = fieldsRes.node?.fields?.nodes || [];
                    const statusField = nodes.find(f => f.name === v2StatusFieldName && f.options);
                    const statusFieldId = statusField?.id;
                    const optionId = statusField?.options?.find(o => o.name === v2StatusOptionName)?.id;
                    if (statusFieldId && optionId) {
                      const setMutation = `mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}){ projectV2Item { id } } }`;
                      await github.graphql(setMutation, { projectId: projectV2Id, itemId, fieldId: statusFieldId, optionId });
                    }
                  }
                } catch {}
              } else {
                // Classic fallback: repo-level only (simple path)
                try {
                  const inertia = { accept: 'application/vnd.github.inertia-preview+json' };
                  const repoProjects = await github.request('GET /repos/{owner}/{repo}/projects', { owner, repo, headers: inertia });
                  const proj = repoProjects.data.find(p => eqNoDiacritics(p.name, projectName));
                  if (proj) {
                    const columns = await github.request('GET /projects/{project_id}/columns', { project_id: proj.id, headers: inertia });
                    const targetCol = columns.data.find(c => eqNoDiacritics(c.name, classicColumnName)) || columns.data[0];
                    await github.request('POST /projects/columns/{column_id}/cards', {
                      column_id: targetCol.id,
                      content_id: child.id,
                      content_type: 'Issue',
                      headers: inertia,
                    });
                  }
                } catch {}
              }

              // Replace line with linked task
              lines[i] = `- [ ] #${child.number} ${text}`;
              changed = true;
            }

            if (changed) {
              issueBody = lines.join('\n');
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body: issueBody });
            }
