name: Autocreate Issues

on:
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  repository-projects: write

jobs:
  create_issues:
    runs-on: ubuntu-latest
    steps:
      - name: Create issues, link to Epic #1, and add to Project "Planificación"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const epicNumber = 1;
            const assignee = 'KronoxYT';
            const projectName = 'Planificación';
            const classicColumnName = 'To do';
            const avoidDuplicates = true;
            const v2StatusFieldName = 'Status';
            const v2StatusOptionName = 'Todo';

            const issuesData = [
              {
                title: 'Implementar “Open Folder” con dialog.open',
                description: 'Permitir al usuario seleccionar una carpeta del sistema utilizando la API de diálogos de Tauri y establecerla como carpeta activa del workspace.',
                ac: [
                  'Se abre un diálogo del sistema para seleccionar carpetas.',
                  'Al confirmar, se guarda la ruta y se notifica a la UI.',
                  'Si el usuario cancela, no cambia el estado actual.',
                  'Se recuerda la última carpeta abierta en la próxima sesión.'
                ]
              },
              {
                title: 'Montar árbol real del FS usando readDir',
                description: 'Listar el contenido de la carpeta activa mostrando un árbol de directorios y archivos reales.',
                ac: [
                  'Se listan carpetas y archivos recursivamente con `readDir`.',
                  'El árbol se actualiza al cambiar de carpeta activa.',
                  'Se muestran iconos y tipos correctos.',
                  'Manejo de errores (permisos / rutas inválidas).' 
                ]
              },
              {
                title: 'Leer archivos con readTextFile',
                description: 'Permitir abrir archivos de texto desde el árbol y cargarlos en el editor Monaco.',
                ac: [
                  'Doble clic o acción equivalente abre el archivo.',
                  'El contenido se muestra en un tab del editor.',
                  'Se detecta el lenguaje por extensión y se establece en Monaco.',
                  'Errores de lectura se muestran en la consola/panel de errores.'
                ]
              },
              {
                title: 'Guardar archivos con writeFile',
                description: 'Persistir cambios del editor en el disco utilizando writeFile.',
                ac: [
                  'Acción “Save” guarda el archivo actual.',
                  'Se actualiza el estado `isDirty` a false tras guardar.',
                  'Manejo de condiciones de carrera y archivos borrados externamente.'
                ]
              },
              {
                title: 'Guardar como usando dialog.save',
                description: 'Permitir guardar el contenido actual con un nuevo nombre o ubicación.',
                ac: [
                  'Se abre un diálogo para elegir ruta/destino.',
                  'Al confirmar, se crea el nuevo archivo y se actualiza el tab.',
                  'Se mantiene el archivo original si se cancela.'
                ]
              },
              {
                title: 'Autosave + restauración de sesión',
                description: 'Guardar automáticamente cambios y restaurar la sesión al reabrir la app (tabs, archivos abiertos, carpeta activa).',
                ac: [
                  'Autosave configurable (on/off, intervalo).',
                  'Restauración de tabs y carpeta activa al arrancar.',
                  'Resiliencia ante archivos movidos/borrados.'
                ]
              },
              {
                title: 'Configurar appConfigDir para persistencia',
                description: 'Utilizar `appConfigDir` para almacenar configuración, sesión y metadatos del workspace.',
                ac: [
                  'Se crea/usa el directorio de config de la app.',
                  'Se define un formato de `workspace.json` para sesión.',
                  'Lectura/escritura robusta con manejo de errores.'
                ]
              },
              {
                title: 'Implementar watcher usando tauri-plugin-fs-watch',
                description: 'Escuchar cambios del sistema de archivos y refrescar árbol y tabs abiertos en tiempo real.',
                ac: [
                  'Se detectan creaciones, cambios y borrados.',
                  'El árbol se refresca sin bloquear la UI.',
                  'Se notifican conflictos cuando un archivo abierto cambia en disco.'
                ]
              }
            ];

            async function ensureLabel(labelName, color = '0e8a16') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (e) {
                await github.rest.issues.createLabel({ owner, repo, name: labelName, color });
              }
            }

            async function findIssueByTitle(title) {
              const q = `repo:${owner}/${repo} type:issue in:title "${title.replace(/"/g, '\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q });
              const match = res.data.items.find(i => i.title.toLowerCase() === title.toLowerCase() && i.state !== 'closed');
              return match || null;
            }

            function buildBody(desc, ac) {
              return [
                desc,
                '',
                '### Criterios de aceptación',
                ...ac.map(item => `- [ ] ${item}`),
                '',
                '_Etiqueta: **todo**_'
              ].join('\n');
            }

            await ensureLabel('todo');

            const results = [];
            for (const item of issuesData) {
              const body = buildBody(item.description, item.ac);
              let found = null;
              if (avoidDuplicates) {
                found = await findIssueByTitle(item.title);
              }
              if (found) {
                try { await github.rest.issues.addLabels({ owner, repo, issue_number: found.number, labels: ['todo'] }); } catch {}
                try { await github.rest.issues.addAssignees({ owner, repo, issue_number: found.number, assignees: [assignee] }); } catch {}
                results.push({ number: found.number, title: item.title });
              } else {
                const res = await github.rest.issues.create({
                  owner,
                  repo,
                  title: item.title,
                  body,
                  labels: ['todo'],
                  assignees: [assignee],
                }).catch(async (err) => {
                  if (err.status === 422 || err.status === 404) {
                    const res2 = await github.rest.issues.create({ owner, repo, title: item.title, body, labels: ['todo'] });
                    return res2;
                  }
                  throw err;
                });
                results.push({ number: res.data.number, title: item.title });
              }
            }

            // Link to Epic #1 as sub-issues via task list in the epic body
            const epic = await github.rest.issues.get({ owner, repo, issue_number: epicNumber });
            let epicBody = epic.data.body || '';
            for (const it of results) {
              const ref = `#${it.number}`;
              if (!epicBody.includes(ref)) {
                epicBody += `\n- [ ] ${ref} ${it.title}`;
              }
            }
            await github.rest.issues.update({ owner, repo, issue_number: epicNumber, body: epicBody });

            // Try to add to Project v2 named "Planificación" (org or user)
            async function findProjectV2Id() {
              try {
                const orgQuery = `query($login:String!){ organization(login:$login){ projectsV2(first:100){ nodes{ id title } } } }`;
                const orgRes = await github.graphql(orgQuery, { login: owner });
                const orgProjects = orgRes.organization?.projectsV2?.nodes || [];
                const foundOrg = orgProjects.find(p => p.title === projectName);
                if (foundOrg) return foundOrg.id;
              } catch {}
              try {
                const userQuery = `query($login:String!){ user(login:$login){ projectsV2(first:100){ nodes{ id title } } } }`;
                const userRes = await github.graphql(userQuery, { login: owner });
                const userProjects = userRes.user?.projectsV2?.nodes || [];
                const foundUser = userProjects.find(p => p.title === projectName);
                if (foundUser) return foundUser.id;
              } catch {}
              return null;
            }

            const projectV2Id = await findProjectV2Id();
            if (projectV2Id) {
              core.summary.addRaw('Proyecto detectado: Project v2', true);
            } else {
              core.summary.addRaw('Proyecto detectado: Project clásico (repo)', true);
            }

            async function getIssueNodeId(number) {
              const q = `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id } } }`;
              const r = await github.graphql(q, { owner, repo, number });
              return r.repository.issue.id;
            }

            if (projectV2Id) {
              const fieldsQuery = `query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2{ fields(first:50){ nodes{ id name dataType ... on ProjectV2SingleSelectField { options { id name } } } } } } }`;
              let statusFieldId = null, statusOptionId = null;
              try {
                const fieldsRes = await github.graphql(fieldsQuery, { projectId: projectV2Id });
                const nodes = fieldsRes.node?.fields?.nodes || [];
                const statusField = nodes.find(f => f.name === v2StatusFieldName && f.options);
                if (statusField) {
                  statusFieldId = statusField.id;
                  const opt = statusField.options.find(o => o.name === v2StatusOptionName);
                  statusOptionId = opt?.id || null;
                }
              } catch {}

              for (const it of results) {
                const nodeId = await getIssueNodeId(it.number);
                const addMutation = `mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`;
                const addRes = await github.graphql(addMutation, { projectId: projectV2Id, contentId: nodeId });
                const itemId = addRes.addProjectV2ItemById?.item?.id;
                if (itemId && statusFieldId && statusOptionId) {
                  const setMutation = `mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}){ projectV2Item { id } } }`;
                  try {
                    await github.graphql(setMutation, { projectId: projectV2Id, itemId, fieldId: statusFieldId, optionId: statusOptionId });
                  } catch {}
                }
              }
            } else {
              // Fallback to classic Projects: try repo -> org -> user
              const inertia = { accept: 'application/vnd.github.inertia-preview+json' };
              async function addToClassicProject(proj, scope) {
                const columns = await github.request('GET /projects/{project_id}/columns', {
                  project_id: proj.id,
                  headers: inertia,
                });
                const targetCol = columns.data.find(c => c.name.toLowerCase() === classicColumnName.toLowerCase()) || columns.data[0];
                for (const it of results) {
                  const issue = await github.rest.issues.get({ owner, repo, issue_number: it.number });
                  await github.request('POST /projects/columns/{column_id}/cards', {
                    column_id: targetCol.id,
                    content_id: issue.data.id,
                    content_type: 'Issue',
                    headers: inertia,
                  });
                }
                core.summary.addRaw(`Añadido a Project clásico (${scope}): ${projectName} → columna "${targetCol.name}"`, true);
                return true;
              }

              let added = false;
              // Repo-level classic project
              try {
                const projects = await github.request('GET /repos/{owner}/{repo}/projects', { owner, repo, headers: inertia });
                const proj = projects.data.find(p => p.name === projectName);
                if (proj) { added = await addToClassicProject(proj, 'repo'); }
              } catch {}

              // Org-level classic project
              if (!added) {
                try {
                  const orgProjects = await github.request('GET /orgs/{org}/projects', { org: owner, headers: inertia });
                  const proj = orgProjects.data.find(p => p.name === projectName);
                  if (proj) { added = await addToClassicProject(proj, 'org'); }
                } catch {}
              }

              // User-level classic project
              if (!added) {
                try {
                  const userProjects = await github.request('GET /users/{username}/projects', { username: owner, headers: inertia });
                  const proj = userProjects.data.find(p => p.name === projectName);
                  if (proj) { added = await addToClassicProject(proj, 'user'); }
                } catch {}
              }

              if (!added) {
                core.warning('No se encontró un Project clásico llamado "' + projectName + '" en repo/org/user, o faltan permisos. Crea el Project o usa uno de Project v2 con el mismo nombre.');
              }
            }

            core.summary.addHeading('Issues creados');
            for (const it of results) {
              core.summary.addList([`#${it.number} ${it.title}`]);
            }
            await core.summary.write();
